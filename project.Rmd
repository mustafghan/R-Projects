---
title: "R For Everyone"
author: "Mustafa Zia"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---
```{r setup}
library(tidyverse)
```

# Chapter 4: Basics of R 

## 4.2 Variables 

### 4.2.1 Variable Assignment
    There are several ways of assigning variables in R. 
```{r}
x <- 2
y = 5
3 -> z
assign ("j", 4)
```

You can do multiple assignments
```{r}
a <- b <- 7
```

### 4.2.2 Removing Variables
```{r}
rm(j) # This frees up memory in R
gc(a) # This frees up memory in the operating system. R does it automatically so you don't necessarily have to do this R does it for you already
```

## 4.3 Data Types

### 4.3.1 Numeric Data
    Integer and Numeric. Integer is also considered a numeric. Assigning integers is like this 
```{r}
i <- 5L
class(i)
is.numeric(i)
```

### 4.3.2 Character Data 
    R has two ways of handling character data: character and factor
```{r}
x <- 'data'
```

To find the length of a character or a numeric you can use nchar

### 4.3.3 Dates
    Use ***as.Date*** to convert to a date
```{r}
date1 <- as.Date("2012-06-28")
```

Using functions such as the ***as.numeric*** or ***as.Date*** does not merely change the formatting of an object but actually changes the underlying type

### 4.3.4 Logical
Not much here. 

## 4.4 Vectors
    R is a vectorized language. Operations are applied to each element of a vector automatically, without the need to loop through the the vector. 

### 4.4.1 Vector Operations
```{r}
vector <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
```

Multiply each element by 3
```{r}
vector * 3
```

Additionally you can do other mathematical operations. You can also create similar vectors using the :, which creates a sequence of numbers in either direction
```{r}
vector_1 <-   2:11
vector_2 <-  -4:5
```

You can perform similar functions by vectors (e.g. multiplying two vectors) if they both have equal lengths. 
```{r}
vector_1 * vector_2 # Multiply
vector_1 + vector_2 # Add
length (vector_1)   # You can check the length with the length statement
```

**Note:** If two unequal operators, then the shorter vectors gets recycled --that is, it's elements are repeated, in order, until they have been matched up with every element of the longer vector. If the longer one is not a multiple of the shorter one, a warning is given. See example below.
```{r}
vector + c(1,2)
```

In this case the Vector which is 1: 10 is a multiple of c(1,2), let's see what happens if it's not with example below:
```{r}
vector + c(1,2,3)
```
You end up with the following vector 2 4 6 5 7 9 8 10 12 11. The C(1,2,3) keeps getting added onto the vector (1:10)
so you get 1 + 1, 2+2, 3+3, 1+4, 2+5, 3+6, 1+7, 2+8, 3+9, 1+10

Comparisons also work on vectors.  Here the result is a vector of the same length containing TRUE of FALSE for each element. 
```{r}
vector <= 5
```

You can this operation on vectors too
```{r}
vector_1 > vector_2
```

You can also use the all or any function to check whether all or any of the comparisons are true. 
```{r}
any(vector_1 < vector_2)
all(vector_1 > vector_2)
any(vector_1 > vector_2)
```

You can also access single, consecutive or nonconsecutive elements of a vector by using the square bracket [ ]
```{r}
vector_1 [1]
vector_2 [5:6] # consecutive
vector[c(1,7)] # nonconsecutive
```

You can also name the vectors either during or after the creation by element
```{r}
Vector_Name <- c(One = "a", Two = "b", Last = "r")
w <- 1:3
names(w) <- c("a", "b", "c")
```

### 4.4.2 Factor Vectors
    Let's create a vector of text data
```{r}
q <- c("Hockey", "Football", "Baseball", "Curling", 'Rugby', "Lacrosse", 'Basketball', 'Tennis', "Cricket", 'Soccer')
q2 <- c(q, "Hockey", "Lacrosse", "Hockey", 'Water Polo', 'Hockey', 'Lacrosse')
```

Now convert to a factor using as.factor
```{r}
q2_Factor <- as.factor(q2)
```

You'll notice R also assigns a unique factor to each element, giving each character element a unique integer value
```{r}
as.numeric(q2_Factor)
```

You can also set the level of the factor
```{r}
factor(x = c("High School", "College", "Masters", "Doctorate"), 
       levels = c ("High School", "College", "Masters", "Doctorate"), 
       ordered= TRUE)
```

## 4.5 Calling Functions 
```{r}
mean (vector)
```

## 4.6 Function Documentation
    Use ***?*** before function to see what it does. If you have a gist of the function, you can use the ***apropos ("mean")*** to find out about it. 
```{r}
apropos ("mea")
```

## 4.7 Mission Data
    Two types: ***NA*** and ***NULL***

### 4.7.1 NA
    R uses ***NA*** to reprsent missing data. You can use the ***is.na*** to check for missingness
```{r}
z <- c(1, 3, NA, 3, NA)
is.na(z)
```

Same thing works for character
If you calculate the mean of z, you will get ***NA*** because even if a single element is missing, the mean won't be calculated
```{r}
mean(z)
```

If you want R to ignore the missing and calculate the mean then use the ***na.rm = TRUE***, which first removes the missing data
```{r}
mean(z, na.rm = TRUE) # This is also true for sum, min, max, var, sd and other functions. 
```

### 4.7.2 NULL
    Unlike ***NA*** which is missingness, ***NULL*** is more like nothingness. You cannot use it within a vector as it will treat it as not existing at all and so it disappears
```{r}
null_check <- c(1, NULL, 6)
null_check
```

When you run the above ***null_check***, it will only return ***1, 6***. You can use ***is.null*** to test for NULL value. 

## 4.8 Pipes
    Using the ***"magrittr"*** package. What the pipe does is it uses the object or value from the left hand side of the pipe and inserts it into the first argument of the function on the right hand side of the pipe. 
```{r}
library(magrittr)
pipe_example <- 1:10
mean(pipe_example)
```

You can do the above using the pipe instead
```{r}
pipe_example %>% mean # ctrl +shift + M is the shortcut
```

Another example
```{r}
pipe_example_2 <- c(1, 3, NA, 6, NA, 3, NA)
sum(is.na(pipe_example_2))
```

Can do the same in Pipe
```{r}
pipe_example_2 %>% is.na %>% sum
```

When piping an object into a function and not seeting any additional arguments, no parenthese are needed. However, if addtional arguments are used, then they should be named and included inside the parentheses after the function call. The first argument is not used, as the pipe already inserted the left-hand object into the first argument. 
```{r}
mean(pipe_example_2, na.rm = TRUE)
```

Or using pipe
```{r}
pipe_example_2 %>% mean (na.rm = TRUE)
```

# Chapter 5: Advanced Data Structures

## 5.1 data.frames 
    ***data.frame*** is just like an Excel spreadsheet in that it has columns and rows. In statistical terms, each column is a variable and each row is an observation. 
    In terms of how R organizes ***data.frames***, each column is actually a vector, each different types of data. This also implies that within a column each element must be of the same type, just like with vectors. 
There are numerous ways to construct a ***data.frame***, the simplest being to use the data.frame function.
```{r}
x <- 10:1
y <- -4:5
q <- c("Hockey", "Football", "Baseball", 'Curling', 'Rugby', "Lacrosse", "Basketball", "Tennis", 'Cricket', 'Soccer')
theDF <- data.frame(x,y,q)
```

We can assign names during the creation process
```{r}
theDF <- data.frame(First = x, Second = y, Sport = q)
```

To check for row and column and both use
```{r}
nrow(theDF)
ncol(theDF)
dim (theDF)
```

...We can also check names
```{r}
names(theDF)
```

...or individual elements
```{r}
names(theDF) [3]
```

We can also assign row names
```{r}
rownames(theDF)
rownames(theDF) <- c("One", "Two", "Three", "Four", "Five", "Six", 'Seveon', 'Eight', 'Nine', "Ten")
rownames(theDF)
```

You can also set it back to generic by the following code
```{r}
rownames (theDF) <- NULL
```

You can use ***head()*** or ***tail()*** to print only first or last few rows from a ***data.frame***
```{r}
head(theDF)
tail(theDF)
```

...or set how many rows you want to see
```{r}
head(theDF, n = 10)
head(theDF, n = 20)
```

We can check the class as well
```{r}
class(theDF)
```

You can access specific column using ***$*** or squar bracket
```{r}
theDF$First
```

You can access position, first is row, second is the column number. So to get the third row from the second column we use 
```{r}
theDF[3, 2]
```

To specify more than one row or column, use a vector of indices. Here it is row 3, columns 2 through 3
```{r}
theDF[3, 2:3]
```

...rows 3 and 5, column 2
since only one column was selected it was returned as a vector
hence the column names will not be printed
```{r}
theDF[c(3,5), 2]
```

...rows 3 and 5, columns 2 through 3
```{r}
theDF[c(3,5), 2:3]
```

To access an entire row, specefif that row, and likewise to access only a column, specify that column. 
```{r}
theDF[ ,3]
```

...all of columns 2 through 3
```{r}
theDF[ ,2:3]
```

...all of row 2
```{r}
theDF[2, ]
```

...all of rows 2 through 4
```{r}
theDF[2:4, ]
```

...you can access multiple columns by name, by making column argument a character vector of the names
```{r}
theDF[, c("First", "Sport")]
```

...yet another way of accessing a specefic column
```{r}
theDF["Sport"]
```

...or the following, and return a (factor) vector
```{r}
theDF[, 'Sport']
class(theDF[, "Sport"])
```

...or the following
```{r}
theDF[["Sport"]]
class(theDF[["Sport"]])
```

To get a single-column ***data.frame*** instead of vector, you can use the ***drop = FALSE***
```{r}
theDF[, "Sport", drop = FALSE]
class(theDF[, "Sport", drop = FALSE])
```

...this does the same
```{r}
theDF[, 3, drop = FALSE]
class(theDF[, 3, drop = FALSE])
```

Factors are stored specially. To see how they would be represented in ***data.frame*** form, use ***modle.matrix*** to create a set of indicators (or dummy) variables. That is one column for each level of a factor, with a 1 if a row contains that level or a 0 otherwise. 
```{r}
newFactor <- factor(c("Pennsylvania", "New York", "New Jersey", "New York", "Tennessee", "Massachusetts", "Pennsylvania", "New York"))
model.matrix(~ newFactor -1)
```

## 5.2 Lists 
    Lists are created with the list function where each argument to the function becomes an element of the list
Create a three element list
```{r}
list(1,2,3)
```

Creates a single element list. The only element is a vector that has three elements
```{r}
list(c(1,2,3))
```

Creates a two element list
1. the first is a three element vector
2. the second element is a five element vector
```{r}
list3 <- list(c(1,2,3), 3:7)
```

Two element list
1. first element is a ***data.frame***
2. second element is a 10 element vector
```{r}
list (theDF, 1:10)
```

Three element list
1. fist is a data.frame
2. second is a vector
3. third is list3 which holds two vectors
```{r}
list5 <- list(theDF, 1:10, list3)
```

Like ***data.frames***, lists can have names. Each element has a unique name that can be either viewed or assigned using names. 
```{r}
names(list5) <- c("data.frame", "Vector", "list")
names(list5)
```

You can also assigned them during creation
```{r}
list6 <- list(TheDataFrame = theDF, TheVector = 1:10, TheList = list3)
names(list6)
```

You can also create an empty list. The bracket in the beginning allows you to show the result while creating using vector
```{r}
(emptyList <- vector(mode = "list", length = 4))
```

To access an individual element of a list, use ***double square []*** brackets, specifying either the element or the name. Note that this allows access to only one element at a time
```{r}
list5[[2]]
```

...or using the name
```{r}
list5[["data.frame"]]
```

Once an element is accessed it can be treated as if that actual element is being used, allowing nested indexing of elements. 
```{r}
list6[[1]]$Sport
```

It is possible to append elements to a list simpl by using an index (either numeric or named) that does not exist. 
```{r}
 length (list5) # See how long it currently is
```

...add a fourth element, unnamed
```{r}
list5[[4]] <- 2
length(list5)
```

...add a fifth element, name
```{r}
list5[["NewElement"]] <- 3:6
length(list5)
names(list5)
```

## 5.3 Matrices
    It is similar to data.frame with one exception: every single element, regardless of column, must be the same type, most commonly all numerics. They also act similarly to Vectors with element-by-element addition, multiplication, subtraction, division and equality. The nrow, ncol, and dim functions work just like they do for data.frames. 

...create a 5x2 matrix
```{r}
A <- matrix(1:10, nrow=5)
```

...create another 5x2 matrix
```{r}
B <- matrix(21:30, nrow=5)
```

...create another 2x10 matrix
```{r}
C <- matrix(21:40, nrow = 2)
```

...you can use nrow, ncol, and dim
```{r}
nrow(A)
ncol(A)
dim(A)
```

...add them
```{r}
A + B # and etc
```

...see if the elements are equal
```{r}
A == B
```

There are two special vectors,letters and LETTERS, that contain the lower case and the upper case letters, respectively.
```{r}
colnames(B) <- LETTERS[1:2]
colnames(C) <- letters[1:10]
```

## 5.4 Arrays
    An array is essentially a multidimensional vector. It must all be of the same type, and individual elements are accessed in a similiar fashion using ***[]***. First element is row index, second is column index, and remaining elements are for outer dimensions. 
```{r}
theArray <- array(1:12, dim = c(2,3,2))

theArrayName <- array(1:12, 
                      dim = c (2,3,3), 
                      dimnames = list(
                          c("One","Two"), 
                          c("Yak", "Doo", "Say"), 
                          c("Aik", "Do", "Theen")))

theArrayName[1, ,] # first element of first row for every column and outside dimension

theArrayName[1, , 1] # first elements of first row of only the first outside dimension

theArrayName[, , 1] # all the elements of the first outside dimension
```

# Chapter 6: Reading Data into R
                       
## 6.1 Reading CSVs 
    ***read.table*** is best way to read CSV files, but we can also use ***read.csv***, which is a wrapper around read.table.

You can read the csv file directly from the website for example. 
```{r}
theUrl <- "http://www.jaredlander.com/data/TomatoFirst.csv"
tomato <- read.table(file = theUrl, header = TRUE, sep = ",")
```

### 6.1.1 read_delim
    We use the ***readr*** package. Bunch of functions for reading text files, with ***read_delim*** the most common for reading text files. This is faster than read.table. 
```{r}
library(readr)
tomato2 <- read_delim(file = theUrl, delim = ",") # This returns a tibble in stead of the regular data.frame.
```

You can also use the ***head.read_delim*** to display the data. The other advantage is that you don't have to specify ***stringsasFactors = FALSE***. Compare the Source column in tomato data.frame (shows it as factor). There are presets of read_csv and read_tsv. 

### 6.1.2 fread
    This is another option for reading large data quickly is fread from the data.table package. The first argument is the full filename or URL of the file to be read. The header argument indicates that the first row of the file holds the column names and the sep specifies the field delimiter. This function has a stringsAsFactors argument that is set to FALSE by default. 
```{r}
library(data.table)
theUrl_2 <- "C:\\Users\\mustafa.zia\\Desktop\\R\\R-Projects\\TomatoFirst.csv"
tomato_1 <- fread(input=theUrl_2,sep=',', header=TRUE)
```

So both read_delim and fread are faster than read.table. The option of which one to use depends on where dplyr or data.table is preferrred for data manipulation. 

## 6.2 Excel Data
    You can read excel files (both xls and xlsx) using the ***read_excel***. However, unlike fread and read_delim, you cannot read the excel file directly from a site. You have to download it first and then single Excel sheet. If you want to do it directly from a website, you can use the ***download.file*** syntax. 
```{r}
download.file(url = 'http://www.jaredlander.com/data/ExcelExample.xlsx', destfile = 'C:\\Users\\mustafa.zia\\Desktop\\R\\R-Projects\\ExcelExample.xlsx', method = 'curl')

```

...ffter downloading the file, we check the sheets in the Excel file. 
```{r}
library(readxl)
excel_sheets('C:\\Users\\mustafa.zia\\Desktop\\R\\R-Projects\\Zia Workplan FY19.xlsx')
```

By default ***read_excel*** reads the first sheet and creates a tibble instead of a data.frame. 
```{r}
tomatoXL <- read_excel('C:\\Users\\mustafa.zia\\Desktop\\R\\R-Projects\\Zia Workplan FY19.xlsx')
```

Specifying which sheet to read can be done by either supplying the sheet position as a number or the actual name of the sheet as a character. 

...using position
```{r}

wineXL <- read_excel ("C:\\Users\\mustafa.zia\\Desktop\\R\\R-Projects\\Zia Workplan FY19.xlsx", sheet = 2)
```

...using name
```{r}
wineXL2 <- read_excel ("C:\\Users\\mustafa.zia\\Desktop\\R\\R-Projects\\Zia Workplan FY19.xlsx", sheet = "Sheet2")
```

## 6.3 - 6.4 Reading from Databases and also from Other Statistical 

You can read from Databases similar to the excel file, but it's not really that widely used anyways. 
You can read files from spss, sas, stata, using the foreign which is similar to read.table in that you get a data.frame. You can also use the haven package and read files into a tibble (read_spss, read_sas, read_stata)

## 6.5 R Binary Files 
    When working with other R programmers, a good way to pass around data--or any R objects such as variables and functions is to use RData files. These are binary files that represents objects of any kind, whether single or multiple objects and can be passed among Windows, Mac, Linux without any issues. Example below

...save the tomata data.frame to disk
```{r}
save(tomato, file = "C:/Users/mustafa.zia/Desktop/R/R-Projects/tomata.rdata")
```

...remove tomato from memory
```{r}
rm(tomato)
```

...read it from the rdata file
```{r}
load("C:\\Users\\mustafa.zia\\Desktop\\R\\R-Projects\\tomata.rdata")
```

Now let's create a few objects to store in a single RData file, remove them and then load them again. 

1. Create some objects
```{r}
n <- 20
r <- 1:10
w <- data.frame(n, r)
```

2. Save them
```{r}
save(n,r,w, file = "C:/Users/mustafa.zia/Desktop/R/R-Projects/multiple.rdata")
```

3. Remove them
```{r}
rm(n,r,w)
```

4. load them
```{r}
load("C:/Users/mustafa.zia/Desktop/R/R-Projects/multiple.rdata")
```

If you just saved the w without the n and the r, then you won't be able to type n and see the value as it is not loaded as a separate object. 
```{r}
save(w, file = "C:/Users/mustafa.zia/Desktop/R/R-Projects/w.rdata")
load("C:/Users/mustafa.zia/Desktop/R/R-Projects/w.rdata")
```

...so now when you type n, you won't get anything cause it wasn't loaded. 

## 6.6 Data Included with R 
You can use the ggplot2 comes with the diamond dataset. You can call it using the data function.
```{r}
data(diamonds, package = 'ggplot2')
```

## 6.7 Extract Data from Web Sites 

### 6.7.1 Simple HTML Tables
If the data is stored neatly in an HTML table, we can use ***readHTMLTable*** in the ***XML package*** to easily extract it. 
```{r eval=FALSE, include=FALSE}
library(XML)
theURL_XML <- "https://www.jaredlander.com/2012/02/another-kind-of-super-bowl-pool/"
bowlPool <- readHTMLTable(theURL_XML, which = 1, header=FALSE, stringsASFactors=FALSE)
```

the ***which*** says which table to read. it could as well be the second, third, or fourth table. 

### 6.7.2 Scraping Web Data
    Information is often scattered about in tables, divs, spans, or other HTML delements. As an example we put the menu and restaurant details for RIbalta, a beloved NY pizzeria, into an HTML file. The address and phone number are stored in an ordered list, section identifiers are in spans and the items and prices are in tables. We use the rvest package to extract the data into a usable format. 
```{r}
library(rvest)
ribalta <- read_html("http://www.jaredlander.com/data/ribalta.html")
class(ribalta)
ribalta
```

By exploring the HTML we see that the address is tored in a span, which is an element of an ordered list. Firs twe use html_nodes to select all span alements within ul elements. .........Won't go much into it. 


## 6.8 Reading JSON Data 
    A popular format for data, especially for APIs and document databases, is JSON, which stands for JavaScript Object Notation. It is a data format, stored in plain text, which is well suited for nested data. The two main R packages for reading JSON data are rjson and jsonlite. 

The data for this example is a sample from a JSON file listing some of our favorite pizza places in New York. There is an entry for each pizzeria. Within that is a Name element and an array, named Details, that holds elements for Address, City, State, Zip and Phone. 

The ***fromJSON*** function reads the file into R and parses the JSON text. By default, it attempts to sipmlify the data into a data.frame. 
```{r}
library(jsonlite)
pizza <- fromJSON('http://www.jaredlander.com/data/PizzaFavorites.json')
```

The result is a two-column data.frame where the first column is the Name and the second column, named Details, is actually a one-row data.frame for each row of the outer data.frame. This may seem odd, but storing objects in cells of data.frames has long been possible and has recently become more and more the norm. We can see the Details is a list-column where each element is a data.frame. 
```{r}
class(pizza)
class(pizza$Details)
class(pizza$Name)
class(pizza$Details[[1]])
```

This nested structure of a data.frame within a data.frame is best unraveled using the tools availalbe in dplyr, tidyr, and purr. 

# Chapter 7: Statistical Graphics

# Chapter 8: Writing R functions 
    Really good for cutting down on code that needs to be repeated over and over again. However, in R it is alittle different compared with other programming languages. 

## 8.1 Hello, World! 
    Function that simply prints "Hello, World!"
```{r}
say.hello <- function()
{
  print("Hello, World!")
}
```
    
First, note that in R the period (.) is just another character and has no special meaning, unlike in other languages. The body of the function is enclosed in curly braces ({}). This is not necessary if the function contains only one line, but that is rare. Notice the indenting for the commands inside the function. While not required, it is good practice to properly indent code to ensure readability. It is here in the body that we put the lines of code we want the function to perform. Calling say.hello() prints as described. 
```{r}
say.hello ()
```


## 8.2 Function Arguments 
    We use the sprintf function. It's first argument is a string with special input characters and subsequent arguments that will be substituted into the special input characters. 

1. One substitution example
```{r}
sprintf("Hello %s", "Jared")
```

2. Two substitution example
```{r}
sprintf("Hello %s, today is %s", "Mustafa","wonderful day")
```

We now use ***sprintf*** to build a string to print based on a function's argument
```{r}
hello.person <- function(name)
{
    print(sprintf("Hello %s", name))
}

hello.person("Mustafa")
hello.person("Sophia")
```

The argument name can be used as a variable inside the function (it does not exist outside the function). It can also be used like any other variable and as an argument to further function calls. 
    We can add a second argument to be printed as well. When calling functions with more than one argument, there are two ways to specify which argument goes with which value, either positionally or by name. 
```{r}
hello.person_2 <- function(first,last)
{
    print(sprintf("Hello %s %s", first, last))
    
}
```

1. By position
```{r}
hello.person_2("Mustafa", "Zia")
```

2. By name
```{r}
hello.person_2(first = "Mustafa", last = "Zia")
```

3. The other order
```{r}
hello.person_2(last = "Zia", first = "Mustafa")
```

4. Just specify one name
```{r}
hello.person_2(last = "Zia", "Mustafa")
```

5. Specify the other
```{r}
hello.person_2(first = "Mustafa", "Zia")
```

Being able to specify the arguments by name adds a lot of flexibility to calling functions. Even partial argument names can be supplied, but it is not really recommended and should be done with caution. 
```{r}
hello.person_2(f = "Mustafa", l = "Zia")
```

### 8.2.1 Default Arguments

When using multiple arguments it is sometimes desirable to not have to enter a value for each. In other languages functions can be overloaded by defining the function multiple times, each with a differing number of arguments. R instead provides the capability to specify default arguments. These can be NULL, characters, numbers, or any valid R object. Let's rewrite hello.person to provide "Doe" as the default last name
```{r}
hello.person_3 <- function(first, last = "Doe")
{print(sprintf("Hello %s %s", first, last))
}
```

1. Call without specifying last
```{r}
hello.person_3 ("Jared")
```

2. Call with a different last
```{r}
hello.person_3 ("Jared", "Lander")
```

### 8.2.2 Extra Arguments

R offers special operator that enables functions to take an arbitrary number of arguments that do not need to be specified in the function definition. this is the dot-dot-dot argument ***(...)***. This should be used very carefully, although it can provide great flexibility. For now we will just see how it can absorb extra arguments; later we will find a use for it when passing arguments between functions. 

First we have to build the function with ***...*** to absorb the extra argument. 
```{r}
hello.person_4 <- function(first, last ="Doe", ...)
{  
    print(sprintf("Hello %s %s", first, last))
}
```
    
1. Call hello.person_4 with an extra argument
```{r}
hello.person_4 ("Jared", extra = "Goodbye")
```

Call it with two valid arguments and a third
```{r}
hello.person_4 ("Jared", "Lander", "Goodbye")
```


## 8.3 Return Values 

Functions are generally used for computing some value, so they need a mechanism to supply that value back to the caller. This is called returning and is done quite easily. There are two ways to accomplish this with R. The value of the last line of code in a function is automatically returned, although this can be bad practice. The return command more explicitly specifies that a value should be returned and the function should be exited. To illustrate, we will build a function that doubles its only arguments and returns that value. 

1. First build it without an explicity return
```{r}
double.num <- function(x)
{
    x * 2
}
double.num(34)
```

2. Now build it with an explicit return
```{r}
double.num_1 <- function(x)
{
    return(x * 2)
}

double.num_1 (55)
```

3. Build it again, this time with another argument after the explicity return
```{r}
double.num_2 <- function(Mustafa)
{
    return(Mustafa * 6)
    
    # below here is not executed because function already exited
    print("Hello!")
    return(17)
}
double.num_2(5)
```


4. build it again, with only one explicit return
```{r}
double.num_3 <- function(y)
{
    (y * 5)
    print("Hello!")
    return(17)
}

double.num_3(5)

```

## 8.4 do.call 

A particularly underused trick is the do.call function. This allows us to specify the name of a function either as a character or as an object, and provide arguments as a list. 
```{r}
do.call("hello.person_4", args=list(first="Shahram", last="Zia"))

do.call(hello.person_3, args=list(first="Mustafa", last = "Zia"))
```
    
This is particularly useful when building a function that allows the user to specify an action. In the following example the user supplies a vector and a function to be run. 
```{r}
run.this <- function(x, func=mean)
{
    do.call(func, args=list(x))
}

```
    
1. Finds the mean by default
```{r}
run.this(1:50)
```

2. Specify to calculate the mean
```{r}
run.this(1:10, mean)
```

3. Calculate the sum
```{r}
run.this (1:10, sum)
```

4. Calculate the standard deviation
```{r}
run.this(2:8, sd)
```

# Chapter 9: Control Statements 

Control statements allow us to control the flow of our programming and cause different things to happen, depending on the values of tests. Tests result in a logical, TRUE or FALSE, which is used in if-like statements. The main control statements are if, else, ifelse, and switch. 

## 9.1 if and else 

The most common test is the if command. It essentially says if something is TRUE, then perform some action; otherwise, do not perform that action. The thing we are testing goes inside parentheses following the if command. The most basic checks are: equal to (==), less than (<), less than or equal to (<=), greater than (>), greater than or equal to (>=) and not equal (!=). 
    
If these tests pass they result in TRUE, and if they fail they result in FALSE. As noted in SEction 4.3.4, TRUE is numerically equivalent to 1 and FALSE is equivalent to 0. 
```{r}
as.numeric(TRUE)
as.numeric(FALSE)
```
    
Tests don't have to be used inside if statements. 
```{r}
1 == 1
1<1  # etc. 
```

Now we show how to use test inside an if statement. 
1. set up a variable to hold 1
```{r}
toCheck <- 1
```

2. if toCheck is equal to 1, print hello
```{r}
if(toCheck == 1)
{
    print("Hello")
}

#if toCheck is equal to 5, print hello
if(toCheck == 5)
{
    print("Mustafa")
}
```

Since toCheck is not equal to 5, when you run it nothing happens. Make sure the whoel statement is run.  
Notice that if statements are similar to functions, in that all statements (there can be one or multiple) go inside curly braces. Life is not always so simple that we want an action only if some relationship is TRUE. We often want a different action if that relationship is FALSE. In the following example we put an if statement followed by an else statement inside a function, so that it can be used repeatedly.

1. First create the function
```{r}
check.bool <- function(a)
{
    if (a == 1)
    {
        # if the input is equal to 1, print hello
        print("hello")
        
    } else
    {
        print("goodbye")
    }
}
```

Notice that else is on the same line as its preceding closing curly brace ***(})***. This is important, as the code will fail otherwise. Now let's use that function and see if it works. 
```{r}
check.bool(1)   # gives you hello
check.bool(0)   # gives you goodbye
check.bool("M") # gives you goodbey
check.bool(TRUE)# gives you hello
```

Anything other than 1 caused the function ti print "goodbye". This is exactly what we wanted. Passing TRUE printed "hello" because TRUE is numerically the same as 1. 
    Perhaps we want to successively test a few cases. That is where we can use else if. We first test a signel statement, then make another test, and then perhaps fall over to catch all. We will test is using a new check.bool
```{r}
check.bool_1 <- function(x)
{    
    if (x==1)
    {
        # if the input is equal to 1, print hello
        print ("Hello")
    }
    else if (x == 0)
    {
        # if the input is equal to 0, print Goodbye
        print ("Goodbye")
    }
    else
    {
        # otherwise print confused
        print("confused")
    }    
}

check.bool_1(1)   # gives you hello
check.bool_1(0)   # gives you Goodbye
check.bool_1("k") # gives you confused
check.bool_1(5)   # gives you confused
check.bool_1(FALSE) # gives you Goodbye
```

## 9.2 Switch 
    If we have multiple cases to check, writing else if repeatedly can be cumbersome and inefficient. This is where switch is most useful. The first argument is the value we are testing. Subsequent arguments are a particular value and what should be the result. The last argument, if not given a value, is the default result. Here we build a function that takes in a value and returns a corresponding result,
```{r}
use.switch <- function(x)
{switch (x, 
         "a" = "first",
         "b" = "second",
         "z" = "last",
         "c" = "third",
         "other")
}
use.switch("a")
use.switch("c")
use.switch("mustafa")
use.switch(TRUE)
```
    
If the first argument is numeric, it is matched positionally to the followin arguments, regardless of the names of the subsequent arguments. If the numeric arguments is greater than the number of subsequent arguments, NULL is returned. 
```{r}
use.switch(2)
use.switch(5)
use.switch(8)

is.null(use.switch(6))

```

## 9.3 ifelese 

While if is like the if statment in traditional languages, ifelse is more like the if function in Excel. The first argument is the condition to be tested (much like in a traditional if statement), the second argument is the return value if the test is TRUE and the third argument is the return value if the test is FALSE. The beauty here -- unlike with the traditional if is that this works with VECTORIZED arguments. As is often the case in R, using vectorization avoids for loops and speeds up our code. The nuances of ifelse can be tricky, so we show numerous examples. We start with a very simple example, testing whether 1 is equal to 1 and printing "Yes" if that is TRUE and "No" if it is FAlSE. 

...see if 1 == 1 
```{r}
ifelse( 1 == 1, "Yes", "No")
```

...see if 1 == 0 
```{r}
ifelse(1 == 0, "Yes", "No")
```

This clearly gives us the results we want. ifelse uses all the regular equality tests seen in Section 9.1 and any other logical tests. It is worth noting, however, that if testing just a single element ( a vector of length 1 or a simple is.na), it is more efficient to use if than ifelse. This can result in nontrivial speedup of our code. 

Next we will illustrate a vectorized first argument. 
```{r}
toTest <- c(1, 1, 0, 1, 0, 1)
ifelse(toTest == 1, "Yes", "No")
```

This returned "Yes" for each element of toTest that equaled 1 and "No" for each element of toTest that did not equal 1. The TRUE and FALSE arguemnts can even refer to the testing element. 
```{r}
ifelse(toTest == 1, toTest*3, toTest)
```
    
...the FALSE argument is repeated as needed
```{r}
ifelse(toTest == 1, toTest*3, "Zero")
```

Now let's say that ***toTest*** has ***NA*** elements. In that case the corresponding result from ifelse is ***NA***
```{r}
toTest[2] <- NA
ifelse(toTest == 1, "Yes", "No")
```

The same goes for the rest of the code. The NA will have the ***NA*** element. 

## 9.4 Compound Tests

Sometimes we want to test more than one relationship at a time. This is done using logical ***and*** and ***or*** operators. Thes are ***&*** and ***&&*** for ***and*** and ***|***. The double form ***(&& or ||)*** is best used in ***if*** and the single form ***(& or |)*** is necessary for ***ifelse***. The double form compares only one element from each side, while the single form compares each element of each side. 
```{r}
a <- c(1,1,0,1)
b <- c(2,1,0,1)
```

...this checks each element of ***a*** and each element of ***b***
```{r}
ifelse(a == 1 & b == 1, "Yes", "No")
```
...this only checks the first element of ***a*** and the first element of ***b***
```{r}
ifelse(a == 1 && b == 1, "Yes", "No")
```

# Chapter 10: Loops, the Un-R Way to Iterate

R offers both ***for*** and ***while*** for loops. 

## 10.1 for Loops

The most commonly used loop is the ***for*** loop. It iterates over an index--provided as a vector--and performs some operations. For a first simple example, we print out the first ten numbers. 
    The loop is declared using ***for***, which takes one English-seeming argument in three parts. The third part is any vector of values of any kind, most commonly numeric or character. The first part is the variable that is iteratively assigned the values in the vector from the third part. The middle part is simply the word ***in*** indicating that the variable (the first part) is in the vector (the third part). 
```{r}
for (i in 1:10)
{
  print (i)
}
```
Here we generated a vector holding the numbers 1 though 10, and then printed each. Notice that this could have been performed simply by using the built-in vectorization of the ***print*** function. 

```{r}
print (1:10)
```
Other things that can be done, but R's built-in vectorization is easier. 

## 10.2 while Loops

Used less frequently thatn the ***for*** loop. It simply runs the code inside the braces repatedly as long as the tested condition proves true. The following example, we print the values of x and iterate it until it reaches 5. 
```{r}
x <- 1
while (x <= 5)
{
    print(x)
    x <- x +1
}
```

## 10.3 Controlling Loops

Sometimes we have to skip to the next iteration of the loop or completely break out of it. This is accomplished with ***next*** and ***break***. We use a ***for*** loop to demonstrate. 

1. **Next**
```{r}
for (i in 1:10)
{
    if (i == 3)
    {
        next
    }
    print(i)
}
```

Notice that the number 3 did not get printed. 
2. **Break**
```{r}
for (i in 1:10)
{
    if (i == 4) 
    {
        break
    }
    print(i)
}
```

Here, even though we told R to iterate over the first ten integers, it stopped after 3 because we borke the loop at 4. 

# Chapter 11: Group Manipulation

## 11.1 Apply Family

Using ***apply, lapply, sapply, and mapply*** is used best for matrices, lists, etc. 

## 11.2 Aggregate

There are a number of different ways to call aggregate, so we will look at perhaps its most convenient method, using a *formula*. 
 We will see *formulas* used to great extent with linear models in Chapter 19, and they play a useful role in R. *Formulas* consist of a left side and a right side separated by a tilde ***(~)***. The left side represents a variable that we want to make a calculation on, and the right side represents a variable (or more) that we want to group the calculation by. We will use the **diamonds** data in the **ggplot2** pacakage. 
```{r}
data (diamonds, package = "ggplot2")
 head(diamonds)
```
 We calculate the average *price* for each type of *cut*: Fair, Good, Very Good, Premium, Ideal. The first argument to aggregate is the formula specifying that price should be broken up (or group by in SQL terms) by cut. The second argument is the data to use, in this case diamonds. The third argument is the function to apply to each subset of the data; for us this will be the mean. 
 
```{r}
aggregate(price ~ cut, diamonds, mean)
```
 
 After the third argument specifying the function, additional named arguments to that function can be passed, such as ***aggregate (price ~ cut, diamonds, mean, na.rm = TRUE)***

To group the data by more than one variable, add the additional variable to the right side of the *formula* separating it with a plus sign ***(+)***
```{r}
aggregate(price ~ cut + color, diamonds, mean)
```

...To aggregate two variables, they must be combined using ***cbind*** on the left side of the formula. 
```{r}
aggregate (cbind(price, carat) ~ cut, diamonds, mean.default)
```

...Multiple variables can be supplied to both the left  and right sides at the same time. 
```{r}
aggregate (cbind(price, carat) ~ cut + color, diamonds, mean)
```

## 11.3 plyr

This uses the "split-apply-combine" method of data manipulation. The core of ***ply*** consists of functions such as ***ddply, llply, and ldply.***. All of these manipulation functions have five letters, with first letter the type of input and the second letter indicates type of output, and always end with three letter ***ply***. For example, ***ddply*** takes in a *data.frame* and ouputs a *data.frame*, ***llply*** takes a *list* and outputs a *list* and ***ldply*** takes in a *list* and ouputs a *data.frame*. 

>Look at the ***Key*** and ***setkey*** functions. 

# Chapter 12: Faster Group Manipulation with *dplyr*

## 12.1 Pipes
Pipes *( %>% )* make everything faster. It is part of the ***magrittr*** package. With pipes we pipe objects into the first arguments of functions. These operations can be chained together, piping the result of one function into the first argument of the next. As an example, we pipe the *diamonds* data into the *head* function and that into the *dim* function. 
```{r}
library(magrittr)
data (diamonds, package = 'ggplot2')
dim(head(diamonds, n = 4))
```

...now doing this in pipe
```{r}
diamonds %>% head(4) %>% dim
```

## 12.2 tbl

The diamonds is in a tbl format and makes reading the tables easier. 

## 12.3 select

The ***select*** function takes a data.frame (or tbl) as its first arguments then the desired columns as subsequent arguments. The function, like all *dplyr* functions, can be used in the traditional, nested manner or with pipes. You use ***select*** for columns only. 

```{r}
select(diamonds, carat, price)
```

... now with pipe
```{r}
diamonds %>% select(carat, price)
```

...the columns can be specified as a vector of column names as well
```{r}
diamonds %>% select(c(carat, price))
```

The regular ***select*** function is designed to take unquoted column names to make interactive use easier. The names can be passed either as individual arguments or as a vector. If quoted column names are necessary, they can be used with the standard evaluation version of ***select***, which has an ***underscore (_)*** at the end of the function. 
```{r}
diamonds %>% select_('carat', 'price')
```

If the column names are stored in a variable, they should be passed to the ***.dots*** argument. 
```{r}
theCols <- c("carat", "price")
diamonds %>% select_(.dots=theCols)
```

The ***select_*** is now depracated function, so you can use ***one_of***. You can use it as following: 
```{r}
diamonds %>% select(one_of("carat", "price"))
```

It is possible to use traditional R square bracket syntax, though the ***dplyr*** printing rules still apply. 
```{r}
diamonds[, c('carat', 'price')]
```

As with the square bracket syntax, column names can be specified by position using their indices. 
```{r}
select(diamonds, 1, 7)
```

...with pipe
```{r}
diamonds %>% select(1,7)
```

Searching for a partial match is done with ***dplyr*** functions ***starts_with, ends_with*** and ***contains***
```{r}
diamonds %>% select(starts_with("c"))
```

```{r}
diamonds %>% select(ends_with("e"))
```

```{r}
diamonds %>% select(contains("1"))
```

Regular expression searches are done with ***matches***. The following code searches for columns that contain the letter *"r"*, followed by any number of wildcard matches and then the letter *"t"*.
```{r}
diamonds %>% select(matches('r.+t'))
```

Columns can be designated not to be selected by preceding the column names or numbers with the minus ***sign (-)***
```{r}
# by name
diamonds %>% select(-carat, -price) 
diamonds %>% select(-c(carat, price))
```

```{r}
# by number
diamonds %>% select(-1, -7)
diamonds %>% select(-c(1, 7))
```

Specifying columsn not to select using quoted names requires putting the minus sign inside the quotes surrounding the names of the undesired columns that are given to the *.dots* argument. 
```{r}
diamonds %>% select_(.dots=c('-carat', '-price'))
diamonds %>% select(-one_of('carat', 'price')) # when using the one_of, use minus before it. 
```


## 12.4 filter
Specifying rows based on a logical expression is done with ***filter***
```{r}
diamonds %>% filter(cut == 'Ideal')
```

The base R equivalent is more verbose and uses square brackets. 
```{r}
diamonds[diamonds$cut == "Ideal",]
```

To filter on a column being equal to one of many possible values the *%in%* operator is used. 
```{r}
diamonds %>% filter(cut %in% c('Ideal', "Good"))
```

All standard equality operators can all be used with *filter*
```{r}
diamonds %>% filter(price>=1000)
```

```{r}
diamonds %>% filter(price != 1000)
```

Compound filtering is accomplished by either separating the expressions with a ***comma(,)*** or an ***ampersand(&)***
```{r}
diamonds %>% filter(carat>2, price<14000)
diamonds %>% filter(carat>2 & price<14000)
```

A logical or statements is expressed with a vertical ***pipe (|)***
```{r}
diamonds %>% filter(carat < 1 | carat > 5)
```

When filtering based on the value of a variable, ***filter_*** is used with a quoted expression. Quoted expressions can be text or expressions preceded with a ***tilde (~).***
```{r}
diamonds %>% filter_("cut == 'Ideal'")
```

```{r}
diamonds %>% filter_(~cut == 'Ideal')
```

... store value as a variable first
```{r}
theCut <- 'Ideal'
diamonds %>% filter_(~cut == theCut)
```

The tricky part is specifying both the value and column as variables, something that might be done while using ***filter_*** inside of a function. The easiest, though perhaps no intended, way to do this is to construct the entire expression as a string using ***sprintf***
```{r}
theCol <- 'cut'
theCut <- 'Ideal'
diamonds %>% filter_(sprintf("%s == '%s'", theCol, theCut))
```

You can also use ***UQE*** and ***as.name*** to do the above. 

## 12.5 slice

While ***filter*** is used for specifying rows based on a logical expression, ***slice*** is used for specifying rows by row number. The desired indices are passed as a vector to ***slice***. 
```{r}
diamonds %>% slice(1:5)
```

...combine different rows
```{r}
diamonds %>% slice(c(1:5, 8, 15:20))
```

Note that the row numbers displayed on the left of the results are not the row numbers indicated by ***slice*** but rather the row numbers of the returned results. Negative indices are used to indicate rows that hsould not be returned. 
```{r}
diamonds %>% slice(-1)
```

## 12.6 mutate

Creating a new columns or modifying existing columns is done with the ***mutate*** function. Creating a new column that is the ratio of *price* and *carat* is as siimplle as providing that ratio as an argument to ***mutate***. 
```{r}
diamonds %>% mutate(price/carat)
```

Depending on the size of the terminal, not all columns will be printed to the screen. To ensure this new column can fit on the screen, we select a few columns of interest using ***select*** and then pipe that result into ***mutate***. 
```{r}
diamonds %>% select(carat, price) %>% mutate(price/carat)
```

The resulting column is unnamed, which is easily remedied by assigning the expression ***(price/carat)*** to a name
```{r}
diamonds %>% select(carat, price) %>% mutate(Ratio = price/carat)
```

Columns created with ***mutate*** can be used immediately in the same ***mutate*** call
```{r}
diamonds %>% 
    select(carat, price) %>% 
    mutate(Ratio=price/carat, Double = Ratio*2)
```

Notice this did not change the *diamonds* data. In order to save changes, the new result needs to be explicitly assigned to the object *diamonds*. 
   A nice feature of the ***magrittr*** package is the assignment pipe ***( %<>% )***, which both pipes the left-hand side into the function on the right-hand side and assigns the result back to the object on the lef-hand side. 
```{r}
diamonds2 <- diamonds
diamonds2
```

```{r}
 diamonds2 %<>%
    select(carat, price) %>% 
    mutate(Ratio = price/carat, Double = Ratio*2)
diamonds2
```
 
This new pipe does not preclude the traditional assignment operator. 
```{r}
diamonds2 <- diamonds2 %>% 
    mutate(Quadruple = Double *2)
diamonds2
```

## 12.7 summarize

While ***mutate*** applies vectorized functions over columns, ***summarize*** applies functions that return a result of length one such as ***mean, max, median*** or other similar functions. This behavior is similar to the ***with*** function in base R. 
```{r}
summarize(diamonds, mean(price))
```

..doing it with pipe
```{r}
diamonds %>% summarize(mean(price))
```

Another nice feature of ***summarize*** is the capability to name the resulting calculation and to perform multiple calculations in the same cell. 
```{r}
diamonds %>% 
    summarize(AvgPrice = mean(price),
              MedianPrice=median(price),
              AvgCarat=mean(carat))
```

## 12.8 group_by

The ***summarize*** function is moderately useful by itself but really shines when used with ***group_by*** to first partition the data and then apply a function to each partition independently. To split the data according to a variable and then apply a summary function to each partition, the data is first passed to ***group_by*** and resulting grouped **data.frame** or **tbl** is passed to ***summarize***, which allows functions to be applied to individual columns. This usage illustrates the power and ease of pipes. 
```{r}
diamonds %>% 
    group_by(cut) %>% 
    summarize(AvgPrice=mean(price))
```

This is a major eloquent, and faster, way to aggregate data than the ***aggregate*** function, and it more easily enables multiple calculations and grouping variables. 
```{r}
diamonds %>% 
    group_by(cut) %>% 
    summarize(AvgPrice=mean(price), SumCarat = sum(carat))
```

```{r}
diamonds %>% 
    group_by(cut, color) %>% 
    summarize(AvgPrice = mean(price), SumCarat = sum(carat))
```

When run on a grouped **data.frame**, the ***summarize*** function drops the innermost level of grouping. That is why the first statement in the previous code returned a **data.frame** with no groups and the second statement returned a **data.frame** with one group. 

## 12.9 arrange

Sorting is performed with the ***arrange*** function, which is much easier to understand and use than the ***order*** and ***sort*** functions from base R. 
```{r}
diamonds %>%
    group_by(cut) %>% 
    summarize(AvgPrice=mean(price), SumCarat = sum(carat)) %>% 
    arrange(AvgPrice) %>% 
# or descending order
    arrange(desc(AvgPrice))
```

## 12.10 do 

For all other general purpose calculation, we have ***do***. 
```{r}
topN <- function(x, N = 5)
{
    x %>% arrange(desc(price)) %>% head(N)
}
```

By combining ***do*** with ***group_by*** we return the top *N* rows, sorted by price, for each cut of diamonds. When using pipes, the lef-hand side becomes the first argument of the function on the right-hand side. For ***do*** the first argument is supposed to be a function, not what is on th lef-hand side of the pipe, in this case the grouped *diamonds* data. Since the lef-hand side is not going to its default location, we specify where it goes by using a period **(.)**
```{r}
diamonds %>% group_by(cut) %>% do(topN(., N = 3))
```

In the above example, the result is a *data.frame*. If we had named the argument, then the expression would result in a data.frame where the calculated column is actually a *list*. 
```{r}
diamonds %>% 
  # group the data ccoding to cut
  #this essentially crates a separate dataset for each
  group_by(cut) %>% 
  # aply the topN function, with the second argument set to 3
  # this is done independently to each group of data
  do(Top = topN(., 3))
```

```{r}
topByCut <- diamonds %>% group_by(cut) %>% do(Top=topN(., 3))
class(topByCut)
```
```{r}
class(topByCut$Top)
class (topByCut[[1]])
topByCut$Top[[1]]
```

## 12.11 dplyr with Databases

dplyr works well with other databses suc as (PostgreSQL, MySQL, etc). For more standard computations, the R code is translated into equivalent SQL code. let's use SQLite database with two tables hodling the *diamonds* data and an additonal, related, dataset. We use the **download.file** to download the database. 
```{r}
download.file("https://www.jaredlander.com/data/diamonds.db", destfile = "data/diamonds.db", mode = "wb")
```

The first step is to create a connection to the database. Starting with **dplyr** version 0.6.0, in order to work with databases **dbplyr** must also be installed, though not necessarily loaded. 
```{r}
diaDBSource <- src_sqlite("data/diamonds.db")
```

See the chapter and google more about this: 

# Chapter 13: Iterating with ***purrr***

You can look this up!

# Chapter 14: Data Reshaping

## 14.1 ***cbind*** and ***rbind***



